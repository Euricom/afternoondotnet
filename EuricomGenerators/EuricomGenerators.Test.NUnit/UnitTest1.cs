using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Demo.Tests.Testing
{
    public enum ProductCategory
    {
        Test = 1,
        Nr2 = 2,
        Yolo
    }
}
namespace EuricomGenerators.Test.NUnit
{
    using Demo.Tests.Testing;
    public class Tests
    {
        [Test]
        public void AssertGeneratorOutputWorkings()
        {
            Assert.That(ProductCategory.Test.GetName(), Is.EqualTo("Test"));
            Assert.That(ProductCategory.Nr2.GetName(), Is.EqualTo("Nr2"));
            Assert.That(ProductCategory.Yolo.GetName(), Is.EqualTo("Yolo"));

            Assert.That(ProductCategoryHelper.GetProductCategoryValue("Test"), Is.EqualTo(ProductCategory.Test));
            Assert.That(ProductCategoryHelper.GetProductCategoryValue("Nr2"), Is.EqualTo(ProductCategory.Nr2));
            Assert.That(ProductCategoryHelper.GetProductCategoryValue("Yolo"), Is.EqualTo(ProductCategory.Yolo));
        }

        [Test]
        public void AssertGeneratorOutput()
        {
            var input = """
                namespace Demo.Tests.Testing
                {
                   public enum ProductCategory
                   {
                      Test = 1,
                      Nr2 = 2,
                      Yolo
                   }
                }
                """;

            Assert.That(GetGeneratedOutput(input), Is.EqualTo(
               $$"""
                // <auto-generated />
                #nullable enable
                using System;

                namespace Demo.Tests.Testing
                {
                    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("EuricomGenerators", "{{typeof(DemoSourceGenerator.SimpleEnumStringGenerator).Assembly.GetName().Version}}")]
                    public static class ProductCategoryHelper
                    {
                        public static string GetName(this ProductCategory @enum)
                            => @enum switch
                                {
                                    ProductCategory.Test => nameof(ProductCategory.Test),
                                    ProductCategory.Nr2 => nameof(ProductCategory.Nr2),
                                    ProductCategory.Yolo => nameof(ProductCategory.Yolo),
                                    _ => throw new ArgumentOutOfRangeException(nameof(@enum), @enum, "Enumeration ProductCategory does not contain this value")
                                };
                
                        public static ProductCategory GetProductCategoryValue(string enumAsString)
                            => enumAsString switch
                                {
                                    nameof(ProductCategory.Test) => ProductCategory.Test,
                                    nameof(ProductCategory.Nr2) => ProductCategory.Nr2,
                                    nameof(ProductCategory.Yolo) => ProductCategory.Yolo,
                                    _ => throw new ArgumentOutOfRangeException(nameof(enumAsString), enumAsString, "Enumeration ProductCategory does not contain this value")
                                };
                    }
                }

                """));
        }

        private static string? GetGeneratedOutput(string sourceCode)
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);
            var references = AppDomain.CurrentDomain.GetAssemblies()
                                      .Where(assembly => !assembly.IsDynamic)
                                      .Select(assembly => MetadataReference.CreateFromFile(assembly.Location))
                                      .Cast<MetadataReference>();

            var compilation = CSharpCompilation.Create("SourceGeneratorTests",
                                                       new[] { syntaxTree },
                                                       references,
                                                       new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

            Assert.That(compilation.GetDiagnostics().Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty, "Base sourcecode should have no error diagnostics");

            var generator = new DemoSourceGenerator.SimpleEnumStringGenerator();
            var driver = CSharpGeneratorDriver.Create(generator)
                                 .RunGeneratorsAndUpdateCompilation(compilation,
                                                                    out var outputCompilation,
                                                                    out var diagnostics);

            Assert.That(outputCompilation.GetDiagnostics().Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty, "New source with source generator should have no error diagnostics");

            // optional
            Assert.That(diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error), Is.Empty, "Source generator should not emit error diagnostics");

            return outputCompilation.SyntaxTrees.Skip(1).LastOrDefault()?.ToString();
        }
    }
}